
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../02_state_format_specific_parser_/">
      
      
        <link rel="next" href="../04_ocr_parser_engine_/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>Chapter 3: PDFMiner Parser Engine - Backend-mod-api-php</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.2afb09e1.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://unpkg.com/mermaid@10.9.1/dist/mermaid.min.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chapter-3-pdfminer-parser-engine" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Backend-mod-api-php" class="md-header__button md-logo" aria-label="Backend-mod-api-php" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Backend-mod-api-php
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chapter 3: PDFMiner Parser Engine
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Backend-mod-api-php" class="md-nav__button md-logo" aria-label="Backend-mod-api-php" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Backend-mod-api-php
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Tutorial: Backend-mod-api-php
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../01_pdf_type_detector_/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 1: PDF Type Detector
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../02_state_format_specific_parser_/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 2: State/Format Specific Parser
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Chapter 3: PDFMiner Parser Engine
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Chapter 3: PDFMiner Parser Engine
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#the-problem-reading-text-inside-a-pdf" class="md-nav__link">
    <span class="md-ellipsis">
      The Problem: Reading Text Inside a PDF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-solution-pdfminer-the-precise-librarian" class="md-nav__link">
    <span class="md-ellipsis">
      The Solution: PDFMiner - The Precise Librarian
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#how-its-used" class="md-nav__link">
    <span class="md-ellipsis">
      How It's Used
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inside-the-engine-a-peek-at-the-code" class="md-nav__link">
    <span class="md-ellipsis">
      Inside the Engine: A Peek at the Code
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    <span class="md-ellipsis">
      Conclusion
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../04_ocr_parser_engine_/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 4: OCR Parser Engine
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../05_layout_analyzer_/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 5: Layout Analyzer
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../06_data_extraction___transformation_/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 6: Data Extraction &amp; Transformation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../07_json_output_formatter_/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Chapter 7: JSON Output Formatter
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#the-problem-reading-text-inside-a-pdf" class="md-nav__link">
    <span class="md-ellipsis">
      The Problem: Reading Text Inside a PDF
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-solution-pdfminer-the-precise-librarian" class="md-nav__link">
    <span class="md-ellipsis">
      The Solution: PDFMiner - The Precise Librarian
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#how-its-used" class="md-nav__link">
    <span class="md-ellipsis">
      How It's Used
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inside-the-engine-a-peek-at-the-code" class="md-nav__link">
    <span class="md-ellipsis">
      Inside the Engine: A Peek at the Code
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    <span class="md-ellipsis">
      Conclusion
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="chapter-3-pdfminer-parser-engine">Chapter 3: PDFMiner Parser Engine</h1>
<p>In <a href="../02_state_format_specific_parser_/">Chapter 2: State/Format Specific Parser</a>, we learned how the system uses specialized parsers for different document types (like NCCI, CA, etc.). We also saw that these parsers need a way to actually <em>read</em> the content from the PDF file.</p>
<p>But how does the parser read a PDF, especially one where you can select the text like in a regular document? That's where our first engine comes in: the <strong>PDFMiner Parser Engine</strong>.</p>
<h2 id="the-problem-reading-text-inside-a-pdf">The Problem: Reading Text Inside a PDF</h2>
<p>Imagine you have a PDF document, like an NCCI mod worksheet. You open it on your computer, and you can highlight and copy the text. This means the text isn't just a picture; it's actually stored <em>as text</em> inside the PDF file.</p>
<p>Our program needs a way to read this text accurately. More importantly, it needs to know <em>exactly where</em> each piece of text is located on the page (its coordinates) so the <a href="../02_state_format_specific_parser_/">State/Format Specific Parser</a> can find specific data fields like "Risk ID" or "Effective Date".</p>
<h2 id="the-solution-pdfminer-the-precise-librarian">The Solution: PDFMiner - The Precise Librarian</h2>
<p>Think of the <strong>PDFMiner Parser Engine</strong> as a meticulous librarian dealing with a perfectly printed book (our text-based PDF). This librarian doesn't just read the words; they carefully note down:</p>
<ol>
<li><strong>The exact text:</strong> "Risk ID:", "12345", "Effective Date:", "01/01/2023"</li>
<li><strong>The precise location:</strong> Where on the page (using X and Y coordinates) each piece of text appears.</li>
<li><strong>Extra details (sometimes):</strong> Like the font used for the text.</li>
</ol>
<p>This engine uses a powerful Python library called <code>pdfminer.six</code> to perform this task. It dives into the internal structure of the PDF file and extracts all the text elements along with their positional information.</p>
<p><strong>Key Function:</strong> To extract text and its coordinates (X, Y) from PDFs where text is directly embedded (not just an image).</p>
<p><strong>Limitation:</strong> It only works if the PDF contains actual text data. If the PDF is just a scanned image or a photo of a document, PDFMiner won't find any text to extract (like asking the librarian to read a book with blank pages). For those cases, we'll need a different tool, the <a href="../04_ocr_parser_engine_/">OCR Parser Engine</a>.</p>
<h2 id="how-its-used">How It's Used</h2>
<p>Remember from Chapter 2, the <a href="../02_state_format_specific_parser_/">State/Format Specific Parser</a> gets called after the <a href="../01_pdf_type_detector_/">PDF Type Detector</a> identifies the document type. If the detector determined the PDF is text-based (like 'NCCI', 'CA', 'NY', etc., and not flagged for OCR), the specific parser will rely on the PDFMiner Parser Engine.</p>
<ol>
<li><strong>Request:</strong> The NCCI Parser (for example) asks the PDFMiner Engine: "Please read this NCCI PDF file and give me all the text elements and their positions."</li>
<li><strong>Processing:</strong> The PDFMiner Engine uses <code>pdfminer.six</code> to analyze the PDF.</li>
<li>
<p><strong>Response:</strong> It returns a detailed list of text elements found on each page. This list might look something like this (simplified):</p>
<p><div class="highlight"><pre><span></span><code>[
  # [ [X_start, Y_bottom, X_end, Y_top], &#39;Text Content&#39;, &#39;Font Name&#39;, FontSize ],
  [ [55, 710, 150, 720], &#39;NCCI Experience Rating Worksheet&#39;, &#39;Arial-BoldMT&#39;, 12 ],
  [ [450, 710, 500, 720], &#39;Risk ID:&#39;, &#39;ArialMT&#39;, 10 ],
  [ [505, 710, 550, 720], &#39;1234567&#39;, &#39;ArialMT&#39;, 10 ],
  [ [55, 690, 150, 700], &#39;Effective Date:&#39;, &#39;ArialMT&#39;, 10 ],
  [ [155, 690, 220, 700], &#39;01/01/2024&#39;, &#39;ArialMT&#39;, 10 ],
  # ... and many more elements
]
</code></pre></div>
4.  <strong>Usage:</strong> The NCCI Parser then uses this precise list and its layout rules (coordinates, keywords) to find and extract the data it needs (as we saw in Chapter 2).</p>
</li>
</ol>
<h2 id="inside-the-engine-a-peek-at-the-code">Inside the Engine: A Peek at the Code</h2>
<p>The core logic for using PDFMiner resides within the various <code>pdf_parser*.py</code> scripts (like <code>pdf_parser.py</code>, <code>pdf_parser_ncci2.py</code>, <code>pdf_parser_ca.py</code>, etc.). They all use the <code>pdfminer.six</code> library.</p>
<p>Let's look at a simplified conceptual flow:</p>
<pre class="mermaid"><code>sequenceDiagram
    participant Parser as State/Format Specific Parser
    participant Engine as PDFMiner Parser Engine (using pdfminer.six)
    participant PDF as PDF File

    Parser-&gt;&gt;Engine: Parse 'my_text_doc.pdf'
    Engine-&gt;&gt;PDF: Open and read structure
    PDF--&gt;&gt;Engine: Provide page objects/elements
    Engine-&gt;&gt;Engine: Analyze page layout, identify text elements
    Engine--&gt;&gt;Parser: Return list of Text Elements [ [[Coords], 'Text', 'Font'], ... ]</code></pre>
<p>Now, let's see a <em>highly simplified</em> example of how the code might extract these elements, inspired by the <code>parse_obj</code> function found in scripts like <code>pdf_parser.py</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Simplified snippet inspired by pdf_parser.py</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pdfminer.layout</span><span class="w"> </span><span class="kn">import</span> <span class="n">LTTextLine</span><span class="p">,</span> <span class="n">LTTextBoxHorizontal</span><span class="p">,</span> <span class="n">LTFigure</span>
<span class="c1"># ... other pdfminer imports ...</span>

<span class="c1"># List to store extracted elements</span>
<span class="n">ListOfStrings</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># This function processes PDF layout objects recursively</span>
<span class="k">def</span><span class="w"> </span><span class="nf">simplified_parse_obj</span><span class="p">(</span><span class="n">layout_objects</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">layout_objects</span><span class="p">:</span>
        <span class="c1"># Is this object a line of text?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">LTTextLine</span><span class="p">):</span>
            <span class="c1"># Get bounding box [X_start, Y_bottom, X_end, Y_top]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">bbox</span>
            <span class="c1"># Get the actual text content</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="c1"># (Optional: Get font info)</span>
            <span class="n">font_info</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fontname</span>
            <span class="c1"># Add to our list</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">:</span> <span class="c1"># Only add if there&#39;s actual text</span>
                 <span class="n">ListOfStrings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">coords</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">font_info</span><span class="p">])</span>

        <span class="c1"># If it&#39;s a container, look inside it for text</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">LTTextBoxHorizontal</span><span class="p">):</span>
            <span class="n">simplified_parse_obj</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_objs</span><span class="p">)</span> <span class="c1"># Recursive call</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">LTFigure</span><span class="p">):</span>
             <span class="n">simplified_parse_obj</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_objs</span><span class="p">)</span> <span class="c1"># Recursive call</span>
        <span class="c1"># (Actual code handles more object types)</span>

<span class="c1"># --- Somewhere else in the parser script ---</span>
<span class="c1"># ... (code to open PDF and get page layout) ...</span>
<span class="c1"># layout = device.get_result() # Get page layout objects</span>

<span class="c1"># Start parsing the objects on the page</span>
<span class="c1"># simplified_parse_obj(layout._objs)</span>

<span class="c1"># Now &#39;ListOfStrings&#39; contains the text elements with coordinates</span>
<span class="c1"># print(ListOfStrings)</span>
<span class="c1"># Output might look like:</span>
<span class="c1"># [ [[55, 710, ...], &#39;NCCI Experience Rating Worksheet&#39;, &#39;Arial-BoldMT&#39;], ...]</span>
</code></pre></div>
<p><strong>Explanation:</strong></p>
<ol>
<li>We import necessary classes from <code>pdfminer.layout</code>.</li>
<li>The <code>simplified_parse_obj</code> function takes PDF objects found on a page.</li>
<li>It loops through each <code>obj</code>.</li>
<li>If an object is an <code>LTTextLine</code> (a line of text), it grabs its coordinates (<code>obj.bbox</code>) and the text content (<code>obj.get_text()</code>), cleans it up, and adds it to our <code>ListOfStrings</code>.</li>
<li>If the object is a container like <code>LTTextBoxHorizontal</code> (a box potentially containing multiple lines) or <code>LTFigure</code>, it calls itself (<code>simplified_parse_obj</code>) to look inside that container. This is called recursion.</li>
<li>After running this on the page layout, <code>ListOfStrings</code> holds the structured text data needed by the <a href="../02_state_format_specific_parser_/">State/Format Specific Parser</a>.</li>
</ol>
<p>The actual code in the project is more complex, handling various PDF quirks, different page coordinate systems, and sorting the results, but the core principle is using <code>pdfminer.six</code> to iterate through page objects and extract text with its precise location.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The PDFMiner Parser Engine is the project's tool for reading PDFs that contain <em>actual text</em>. It acts like a precise librarian, using the <code>pdfminer.six</code> library to extract not just the words but also their exact coordinates (X, Y) on the page. This detailed information is essential for the <a href="../02_state_format_specific_parser_/">State/Format Specific Parser</a> to accurately locate and extract data based on the document's specific layout.</p>
<p>However, what happens when the PDF is just an image, like a scan? PDFMiner can't read pictures of text. For that, we need a different kind of engine.</p>
<p><strong>Next:</strong> <a href="../04_ocr_parser_engine_/">Chapter 4: OCR Parser Engine</a></p>
<hr />












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="https://unpkg.com/mermaid@10.9.1/dist/mermaid.min.js"></script>
      
    
  </body>
</html>